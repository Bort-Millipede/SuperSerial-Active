/*
	SuperSerialNodeHttpHandler.java
	
	//PUT CORRECT VERSION/DATE HERE
	v0.2.1 (1/25/2016)
	
	Handler for custom contexts that are generated by requests made to the /queue context. Allows a single file to be uploaded (via PUT request)
	or a single access entry (via GET request with URL parameter write=true) to be recorded. Also allows uploaded file or access entry to be
	downloaded (via GET request). All requests require the randomly-generated authentication token GUID (generated by the SuperSerialNode class
	at execution start) to be included as a URL parameter.
	
	accepted url-parameters:
		token (required): authentication token GUID
		write (option): whether to download uploaded file/access entry (false) or record access entry (true)
*/

package superserial.node;

import com.sun.net.httpserver.*;
import java.io.*;
import java.util.*;
import java.net.URI;
import java.text.SimpleDateFormat;
import org.json.JSONObject;

public class SuperSerialNodeHttpHandler implements HttpHandler {
	private String token; //authentication token submitted
	private String path; //the actual path where the context is hosted
	private File tempFile; //local file used to store uploaded file
	private boolean written; //whether data was written to local file
	private boolean uploaded; //whether data written to local file was an uploaded file (true) or an access entry (false)
	private String source; //hostname (or IP) of client that uploaded the file
	private String time; //time that file was uploaded
	
	private static final String tempDir = System.getProperty("java.io.tmpdir")+"SuperSerial"+System.getProperty("file.separator");
	
	public SuperSerialNodeHttpHandler(String t,String p) {
		token = t;
		path = p;
		tempFile = null;
		written = false;
		uploaded = false;
		source = null;
	}
	
	public void handle(HttpExchange exchange) {
		Date currTime = new Date(); //current time to be used as upload time (if file is successfully uploaded)
		try {
			String method = exchange.getRequestMethod();
			//SuperSerialNodeHelper.printLogEntry(method+" request received by "+path+" from "+exchange.getRemoteAddress().getHostString());
			
			URI uri = exchange.getRequestURI();
			Headers reqHeaders = exchange.getRequestHeaders();
			String clientToken = null;
			Hashtable<String,String> urlParams = SuperSerialNodeHelper.parseURLParams(uri.getQuery());
			if((urlParams!=null) && urlParams.containsKey("token")) {
				clientToken = urlParams.get("token");
			}
			
			InputStream is = null; //request body
			OutputStream os = null; //response body
			ByteArrayOutputStream baos = null;
			
			if(token.equalsIgnoreCase(clientToken)) {
				JSONObject retJson = new JSONObject();
				switch(method) {
					case "PUT": //upload a file
						String jsonStr = null;
						if((tempFile == null) && (!written)) { //if no file has been already uploaded, read file from request
							is = exchange.getRequestBody();
							baos = new ByteArrayOutputStream();
							byte[] buffer = new byte[1024];
							
							//read PUTted file from request and write to memory
							int nRead = is.read(buffer,0,buffer.length);
							while(nRead != -1) {
								baos.write(buffer,0,nRead);
								nRead = is.read(buffer,0,buffer.length);
							}
							baos.flush();
							baos.close();
							is.close();
							
							//save PUTted file to temporary file
							byte[] fileArray = baos.toByteArray();
							//tempFile = File.createTempFile("SuperSerial-"+path.substring(1)+"-",null);
							tempFile = new File(tempDir,"SuperSerial-"+path.substring(1)+".tmp");
							FileOutputStream fos = new FileOutputStream(tempFile);
							fos.write(fileArray);
							fos.flush();
							fos.close();
							written = true;
							uploaded = true;
							source = exchange.getRemoteAddress().getHostString();
							time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(currTime);
							SuperSerialNodeHelper.printLogEntry("File (size: "+fileArray.length+" bytes) uploaded successfully to "+path+" by "+source);
							
							//return successful response
							retJson.put("status","Success");
							jsonStr = retJson.toString();
							Headers respHeaders = exchange.getResponseHeaders();
							respHeaders.add("Content-Type","application/json");
							exchange.sendResponseHeaders(200,jsonStr.length());
							os = exchange.getResponseBody();
							os.write(jsonStr.getBytes());
							os.flush();
							os.close();
						} else { //if file has already been uploaded (or access entry written), return failure response
							exchange.getRequestBody().close();
							
							//return failure response
							retJson.put("status","Failure: file already uploaded");
							jsonStr = retJson.toString();
							SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (file already uploaded)");
							Headers respHeaders = exchange.getResponseHeaders();
							respHeaders.add("Content-Type","application/json");
							exchange.sendResponseHeaders(500,jsonStr.length());
							os = exchange.getResponseBody();
							os.write(jsonStr.getBytes());
							os.flush();
							os.close();
						}
						break;
					case "GET": //retrieve uploaded file
						
						//check for write parameter
						boolean write=false;
						if((urlParams!=null) && urlParams.containsKey("write")) {
							write=Boolean.parseBoolean(urlParams.get("write"));
						}
						
						if(!write) { //if request is to read uploaded file
							if((tempFile != null) && (written)) { //if a file is ready for reading
								exchange.getRequestBody().close();
								
								//read temporary file into memory
								FileInputStream fis = new FileInputStream(tempFile);
								baos = new ByteArrayOutputStream();
								byte[] buffer = new byte[1024];
								
								int nRead = fis.read(buffer,0,buffer.length);
								while(nRead != -1) {
									baos.write(buffer,0,nRead);
									nRead = fis.read(buffer,0,buffer.length);
								}
								baos.flush();
								baos.close();
								fis.close();
								byte[] fileArray = baos.toByteArray();
								
								//check if file was uploaded or if context was accessed only, then submit response headers
								Headers respHeaders = exchange.getResponseHeaders();
								if(uploaded) { //file was uploaded: add source and upload time to response headers
									respHeaders.add("Upload-Source",source);
									respHeaders.add("Upload-Time",time);
								} else { //no file was uploaded: add content-type to response headers
									respHeaders.add("Content-Type","application/json");
								}
								exchange.sendResponseHeaders(200,fileArray.length);
								
								//write temporary file to response
								os = exchange.getResponseBody();
								os.write(fileArray);
								os.flush();
								os.close();
								if(uploaded) {
									SuperSerialNodeHelper.printLogEntry("File (size: "+fileArray.length+" bytes) downloaded successfully from "+path+" by "+exchange.getRemoteAddress().getHostString());
								} else {
									SuperSerialNodeHelper.printLogEntry("Access entry downloaded successfully from "+path+" by "+exchange.getRemoteAddress().getHostString());
								}
								
							} else { //if no file was written, return failure response
								exchange.getRequestBody().close();
								
								//return failure response
								retJson.put("status","Failure: no file uploaded");
								jsonStr = retJson.toString();
								SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (no file or access entry to download)");
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(500,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							}
						} else { //write parameter supplied and true: write access entry to file
							if((tempFile == null) && (!written)) { //if no file has been already uploaded
								source = exchange.getRemoteAddress().getHostString();
								time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(currTime);
								//tempFile = File.createTempFile("SuperSerial-"+path.substring(1)+"-",null);
								tempFile = new File(tempDir,"SuperSerial-"+path.substring(1)+".tmp");
								FileOutputStream fos = new FileOutputStream(tempFile);
								
								//create access entry JSON
								JSONObject entry = new JSONObject();
								entry.put("accessSource",source);
								entry.put("accessTime",time);
								
								//write entry JSON to file
								fos.write(entry.toString().getBytes());
								fos.flush();
								fos.close();
								written = true;
								SuperSerialNodeHelper.printLogEntry("Access entry successfully written to "+path+" by "+source);
								
								//return successful response
								retJson.put("status","Success");
								jsonStr = retJson.toString();
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(200,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							} else { //if another file or access entry has been written: return failure response
								exchange.getRequestBody().close();
								
								//return failure response
								retJson.put("status","Failure: file already uploaded");
								jsonStr = retJson.toString();
								SuperSerialNodeHelper.printLogEntry(method+"request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (file already uploaded or access entry already written)");
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(500,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							}
						}
						break;
					case "BITS_POST": //BITS upload request (not yet implemented)
						/*exchange.getRequestBody().close();
						Headers respHeaders = exchange.getResponseHeaders();
						respHeaders.add("BITS-Packet-Type","ACK");
						respHeaders.add("BITS-Protocol",reqHeaders.getFirst("BITS-Supported-Protocols"));
						respHeaders.add("BITS-Session-Id","00000000-0000-0000-0000-000000000000");
						exchange.sendResponseHeaders(201,-1);
						exchange.getResponseBody().close();
						break;*/
					case "DELETE": //remove context (not yet implemented)
					default: //unsupported method: reject request with HTTP 405 response
						exchange.getRequestBody().close();
						exchange.sendResponseHeaders(405,-1);
						//exchange.getResponseBody().close();
						SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (unsupported HTTP method: "+method+")");
						break;
				}
			} else {
				exchange.getRequestBody().close();
				exchange.sendResponseHeaders(401,0);
				exchange.getResponseBody().close();
				SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (wrong authentication token)");
			}
			
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}
}
